{"title":"LeetCode 1-50","uid":"18fe105d7c8cde2f9eebd0e775b3d96c","slug":"LeetCode","date":"2023-01-08T12:21:00.000Z","updated":"2023-02-08T14:02:29.999Z","comments":true,"path":"api/articles/LeetCode.json","keywords":null,"cover":null,"content":"<h3 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和*\"></a>1.两数之和<a href=\"https://leetcode.cn/problems/two-sum/\">*</a></h3><pre><code>哈希表插入和查询操作复杂度都是0（1）\n</code></pre>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    unordered_map&lt;int,int&gt;p;\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123; \n            int r &#x3D; target - nums[i];\n            if(p.count(r)) return &#123;p[r], i&#125;;\n            p[nums[i]] &#x3D; i;\n        &#125; \n        return &#123;&#125;;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加**\"></a>2.两数相加<a href=\"https://leetcode.cn/problems/add-two-numbers/\">**</a></h3><pre><code>两个链表按逆序相加\n</code></pre>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n      ListNode *p &#x3D; l1, *q &#x3D; l2;\n      ListNode *pre &#x3D; new ListNode(), *r &#x3D; pre;\n      int t &#x3D; 0, a , b;\n      while(p || q || t) \n      &#123;\n          a &#x3D; p ? p-&gt;val : 0;\n          b &#x3D; q ? q-&gt;val : 0;\n          if(p) p &#x3D; p-&gt;next;\n          if(q) q &#x3D; q-&gt;next;\n          t +&#x3D; a + b;\n          r-&gt;next &#x3D; new ListNode(t % 10);\n          t &#x2F;&#x3D; 10;\n          r &#x3D; r-&gt;next;\n      &#125;\n      return pre-&gt;next;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"3-无重复字符的最长字串\"><a href=\"#3-无重复字符的最长字串\" class=\"headerlink\" title=\"3.无重复字符的最长字串***\"></a>3.无重复字符的最长字串<a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">***</a></h3><pre><code>双指针扫描O(n), 定义两个指针i,j(i&lt;=j), [i, j]\n1. 指针j向后移一位，同时将哈希表s[j]的计数加1\n2. 假设j移动前的区间[i,j]中没有重复字符，则j移动后，只有s[j]可能出现2次，因此我们不断向后移动i, 直至区间[i,j]中s[j]的个数为1\n</code></pre>\n<p>   <strong>注意字串和子序列的区别：字串一定是连续的一段， 子序列不一定是连续的一段，但下标是递增的</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int lengthOfLongestSubstring(string s) &#123; \n       unordered_map&lt;char, int&gt; p;\n       int res &#x3D; 0; \n       for(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n           p[s[i]] ++;         &#x2F;&#x2F; j可以向前移动p[s[i]] - 1步\n           while(p[s[i]] &gt; 1) p[s[j++]] --;    &#x2F;&#x2F;遇到连续重复的序列，j要右移   \n           res &#x3D; max(res, i - j + 1);\n       &#125;\n       return res;\n   &#125;</code></pre>\n\n<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4.寻找两个正序数组的中位数*****\"></a>4.寻找两个正序数组的中位数<a href=\"https://leetcode.cn/problems/median-of-two-sorted-arrays/description/\">*****</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; \n        int tot &#x3D; nums1.size() + nums2.size();\n        if(tot % 2 &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F;序列长度为偶数\n            int left &#x3D; find(nums1, 0, nums2, 0, tot &#x2F; 2);\n            int right &#x3D; find(nums1, 0, nums2, 0, tot &#x2F; 2 + 1);\n            return (left + right) &#x2F; 2.0;\n        &#125;\n        else \n            return find(nums1, 0, nums2, 0, tot &#x2F; 2 + 1);\n    &#125; \n    &#x2F;&#x2F;找到nums1从i开始, nums2从j开始，第k大的元素\n    int find(vector&lt;int&gt; &amp;nums1, int i, vector&lt;int&gt; &amp;nums2, int j, int k) &#123;\n        &#x2F;&#x2F;nums1可用的序列长度大于nums2可用的序列长度\n        if(nums1.size() - i &gt; nums2.size() - j) return find(nums2, j, nums1, i, k);\n        if(k &#x3D;&#x3D; 1) &#123;        &#x2F;&#x2F;找到第一大的元素\n            if(nums1.size() &#x3D;&#x3D; i) return nums2[j];\n            else    return min(nums1[i], nums2[j]);\n        &#125;\n        &#x2F;&#x2F;nums1可用序列为空\n        if(nums1.size() &#x3D;&#x3D; i) return nums2[j + k - 1];\n        &#x2F;&#x2F;si为nums1的可能到达的新位置，向右移动k&#x2F;2\n        int si &#x3D; min((int)nums1.size(), i + k &#x2F; 2), sj &#x3D; j + k - k &#x2F; 2;\n        if(nums1[si - 1] &lt; nums2[sj - 1])   &#x2F;&#x2F;nums1中前k&#x2F;2个元素都小于num2的第k&#x2F;2位置的值，\n            return find(nums1, si, nums2, j, k - (si - i));     \n            &#x2F;&#x2F;在nums1的[si,nums1.size() - 1], nums2的[j, nums2.size() - 1]的范围内找第k - (si - i)个元素\n            &#x2F;&#x2F;即等价于在nums1[i, nums1.size() - 1], nums2在[j, nums2.size() - 1]内找第K个元素\n        else    \n            return find(nums1, i, nums2, sj, k - (sj - j));\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5.最长回文子串***\"></a>5.最长回文子串<a href=\"https://leetcode.cn/problems/longest-palindromic-substring/description/\">***</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string longestPalindrome(string s) &#123;\n        string res;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            &#x2F;&#x2F;回文串为偶数长度\n            int l &#x3D; i - 1, r &#x3D; i + 1;\n            while(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;     \n            if(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);    &#x2F;&#x2F;从 l+1位开始，长度为r-l-1的字串\n            &#x2F;&#x2F;回文串为奇数长度\n            l &#x3D; i, r &#x3D; i + 1;\n            while(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;\n            if(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6.Z字形变换****\"></a>6.Z字形变换<a href=\"https://leetcode.cn/problems/zigzag-conversion/description/\">****</a></h3><ol>\n<li>找规律：第一行和最后一行是公差为2<em>n - 2的等差数列以i为起始点 ，第二行到倒数第二行也一样，但斜线上是2</em>n - 2 -i为起始点公差为2*n - 2的等差数列<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convert(string s, int n) &#123;\n        if(n &#x3D;&#x3D; 1) return s;\n        string res;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;\n                for(int j &#x3D; i; j &lt; s.size(); j +&#x3D; 2 * n - 2) \n                    res +&#x3D; s[j];\n            &#125;\n            else &#123;\n                for(int j &#x3D; i, k &#x3D; 2 * n - 2 - i; j &lt; s.size() || k &lt;s.size(); j +&#x3D; 2 * n - 2, k +&#x3D; 2*n -2) &#123;\n                    if(j &lt; s.size()) res +&#x3D; s[j];\n                    if(k &lt; s.size()) res +&#x3D; s[k];\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n<pre><code>2. 模拟Z路径: i = 0 或 i = n - 1时，变换路径方向\n</code></pre>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convert(string s, int n) &#123; \n        if(n &#x3D;&#x3D; 1) return s;\n        vector&lt;string&gt; v;\n        v.resize(n);\n        int flag &#x3D; -1;\n        int i &#x3D; 0;\n        for(auto x : s) &#123;\n            if(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) \n                flag &#x3D; - flag;\n            v[i] +&#x3D; x;\n            i +&#x3D; flag;\n        &#125;\n        for(int i &#x3D; 1; i &lt; n; i++) \n            v[0] +&#x3D; v[i];\n        return v[0];\n    &#125;\n&#125;;</code></pre></li>\n</ol>\n<h3 id=\"7-整数反转\"><a href=\"#7-整数反转\" class=\"headerlink\" title=\"7.整数反转**\"></a>7.整数反转<a href=\"https://leetcode.cn/problems/reverse-integer/description/\">**</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int reverse(int x) &#123;\n        int res &#x3D; 0;\n        while(x) &#123; \n&#x2F;&#x2F;     res * 10 + x % 10 &gt; INT_MAX\n            if(res &gt; 0 &amp;&amp; res &gt; (INT_MAX - x % 10) &#x2F; 10) return 0;\n&#x2F;&#x2F;     res * 10 + x % 10 &lt; INT_MIN\n            if(res &lt; 0 &amp;&amp; res &lt; (INT_MIN - x % 10) &#x2F; 10) return 0;\n            res &#x3D; 10 * res + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"8-字符串转换整数-atoi\"><a href=\"#8-字符串转换整数-atoi\" class=\"headerlink\" title=\"8.字符串转换整数(atoi)****\"></a>8.字符串转换整数(atoi)<a href=\"https://leetcode.cn/problems/string-to-integer-atoi/description/\">****</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int myAtoi(string s) &#123;\n        int k &#x3D; 0;\n        while(k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39; &#39;) k++;     &#x2F;&#x2F;跳过前导空格\n        int minus &#x3D; 1;\n        if(s[k] &#x3D;&#x3D; &#39;-&#39;) minus &#x3D; -1, k++;       &#x2F;&#x2F;负数\n        else if(s[k] &#x3D;&#x3D; &#39;+&#39;) k++;               &#x2F;&#x2F;正数\n        int res &#x3D; 0;\n        while(k &lt; s.size() &amp;&amp; s[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[k] &lt;&#x3D; &#39;9&#39;) &#123;         &#x2F;&#x2F;非数字字符或者末尾时，退出\n            int x &#x3D; s[k] - &#39;0&#39;; \n            if(minus &gt; 0 &amp;&amp; res &gt; (INT_MAX - x) &#x2F; 10)    return INT_MAX;    &#x2F;&#x2F;正溢出\n            if(minus &lt; 0 &amp;&amp; -res &lt; (INT_MIN + x) &#x2F; 10)   return INT_MIN;    &#x2F;&#x2F;负溢出\n            if(- 10 * res - x &#x3D;&#x3D; INT_MIN)    return INT_MIN;        &#x2F;&#x2F;res为正数时，存在等于最小负数整数的情况     \n            res &#x3D; 10 * res + x;\n            k++;\n        &#125;\n        return minus * res;     &#x2F;&#x2F;加上符号\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9.回文数*\"></a>9.回文数<a href=\"https://leetcode.cn/problems/palindrome-number/description/\">*</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPalindrome(int x) &#123;\n        if( x &lt; 0) return 0;\n        long long res &#x3D; 0, n &#x3D; x;\n        while(x) &#123;\n            res &#x3D; 10 * res + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res &#x3D;&#x3D; n;\n    &#125;\n&#125;;\n&#96;&#96;&#96;&#96;\n### 10.正则表达式匹配[*****](https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;regular-expression-matching&#x2F;description&#x2F;)\n&#96;&#96;&#96; c++\nclass Solution &#123;\n非递归：\npublic:\n    bool isMatch(string s, string p) &#123;\n        int n &#x3D; s.size(), m &#x3D; p.size();\n        s &#x3D; &#39; &#39; + s;\n        p &#x3D; &#39; &#39; + p;\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        f[0][0] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) \n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n                if(j + 1 &lt;&#x3D; m &amp;&amp; p[j + 1] &#x3D;&#x3D; &#39;*&#39;) continue;         \n                &#x2F;&#x2F;a*是组合在一起的被归纳在else if(p[j] &#x3D;&#x3D;&#39;*&#39;)\n                else if(i &amp;&amp; p[j] !&#x3D; &#39;*&#39;)       &#x2F;&#x2F;s不为空，p[j]是有效字符\n                    f[i][j] &#x3D; f[i - 1][j - 1] &amp;&amp; (s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;.&#39;);\n                else if(p[j] &#x3D;&#x3D; &#39;*&#39;)        &#x2F;&#x2F;p[j]与p[j - 1]组合使用，\n                    f[i][j] &#x3D; f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;);\n                    &#x2F;&#x2F;f[i][j - 2]: *表示零个p[j - 1]的情况 或者 s[0 ~ i]可以匹配p[0 ~ j - 2]\n                    &#x2F;&#x2F;f[i - 1][j]表示s[0 ~ i - 1]与p[0 ~ j]所匹配，s[i]又与p[0 ~ j]所匹配 &#x3D;》\n                    &#x2F;&#x2F;f[i - 1][j]： s[0 ~ i] 与 p[0 ~ j]匹配\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11.盛最多水的容器***\"></a>11.盛最多水的容器<a href=\"https://leetcode.cn/problems/container-with-most-water/description/\">***</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) &#123;\n        int i &#x3D; 0, j &#x3D; height.size() - 1;\n        int res &#x3D; 0;\n        while(i &lt; j) &#123;\n            res &#x3D; max(res, (j - i) * min(height[i], height[j]));\n            if(height[i] &lt; height[j]) i++;        \n            &#x2F;&#x2F;容器左端高度小于右端高度，如果存在其他的最大值，那么左端右移\n            else j--;\n            &#x2F;&#x2F;容器左端高度大于右端高度，如果存在其他的最大值，那么右端左移\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"12-整数转罗马数字\"><a href=\"#12-整数转罗马数字\" class=\"headerlink\" title=\"12.整数转罗马数字***\"></a>12.整数转罗马数字<a href=\"https://leetcode.cn/problems/integer-to-roman/description/\">***</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string intToRoman(int num) &#123;\n        int values[] &#x3D; &#123;\n            1000,\n            900, 500, 400, 100,\n            90, 50, 40, 10,\n            9, 5, 4, 1\n        &#125;;\n        string s[] &#x3D; &#123;\n                &quot;M&quot;,\n                &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;,\n                &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;,\n                &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;\n        &#125;;\n        string res;\n        for(int i &#x3D; 0; i &lt; 13; i++) &#123;\n            while(num &gt;&#x3D; values[i]) &#123;\n                num -&#x3D; values[i];\n                res +&#x3D; s[i];\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"13-罗马数字转整数\"><a href=\"#13-罗马数字转整数\" class=\"headerlink\" title=\"13.罗马数字转整数**\"></a>13.罗马数字转整数<a href=\"https://leetcode.cn/problems/roman-to-integer/description/\">**</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int romanToInt(string s) &#123;\n        unordered_map&lt;char,int&gt; hash;\n        hash[&#39;I&#39;] &#x3D; 1, hash[&#39;V&#39;] &#x3D; 5;\n        hash[&#39;X&#39;] &#x3D; 10, hash[&#39;L&#39;] &#x3D; 50;\n        hash[&#39;C&#39;] &#x3D; 100, hash[&#39;D&#39;] &#x3D; 500;\n        hash[&#39;M&#39;] &#x3D; 1000;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i + 1 &lt; s.size() &amp;&amp; hash[s[i]] &lt; hash[s[i + 1]]) &#123;\n                res -&#x3D; hash[s[i]];\n            &#125;\n            else res +&#x3D; hash[s[i]];\n            cout&lt;&lt;res&lt;&lt;endl;\n        &#125;\n        return res;\n    &#125;   \n&#125;;</code></pre>\n<h3 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14.最长公共前缀*\"></a>14.最长公共前缀<a href=\"https://leetcode.cn/problems/longest-common-prefix/description/\">*</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        string s;\n        int k &#x3D; INT_MAX;\n        for(int i &#x3D; 0; i &lt; strs.size(); i++)\n            k &#x3D; min(k, (int)strs[i].size());\n        if(!k) return s;\n        for(int i &#x3D; 0; i &lt; k; i++) &#123;\n            bool flag &#x3D; 1;\n            for(int j &#x3D; 1; j &lt; strs.size(); j++)\n                if(strs[j][i] !&#x3D; strs[0][i]) &#123;\n                    flag &#x3D; 0;\n                    break;\n                &#125;\n            if(flag) s +&#x3D; strs[0][i];\n            else break;\n        &#125;\n        return s;\n    &#125;\n&#125;;</code></pre>\n<h3 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15.三数之和****\"></a>15.三数之和<a href=\"https://leetcode.cn/problems/3sum/description/\">****</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());     &#x2F;&#x2F;对数组进行排序\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            &#x2F;&#x2F;题目要求不要重复的三元组\n            if(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i -1]) continue;\n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                &#x2F;&#x2F;跳过重复的三元组\n                if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n                &#x2F;&#x2F;确定k的位置了，跳过不满足nums[i] + nums[j] + nums[k] &gt; 0\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; 0) k--;\n                if(nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0) &#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"最接近的三数之和\"><a href=\"#最接近的三数之和\" class=\"headerlink\" title=\"最接近的三数之和****\"></a>最接近的三数之和<a href=\"https://leetcode.cn/problems/3sum-closest/description/\">****</a></h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n        sort(nums.begin(), nums.end());\n        pair&lt;int, int&gt; res(INT_MAX, INT_MAX);\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) \n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                while(k - 1 &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; target) k--;\n                int s &#x3D; nums[i] + nums[j] + nums[k];\n                res &#x3D; min(res, make_pair(abs(s - target), s));\n                if(k - 1 &gt; j) &#123;\n                    s &#x3D; nums[i] + nums[j] + nums[k - 1];\n                    res &#x3D; min(res, make_pair(target - s, s));\n                &#125;\n            &#125;\n        return res.second;\n    &#125;\n&#125;;</code></pre>","text":"1.两数之和*哈希表插入和查询操作复杂度都是0（1） class Solution &#123; public: unordered_map&lt;int,int&gt;p; vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","count":1,"path":"api/tags/LeetCode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">1.两数之和</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0\"><span class=\"toc-text\">2.两数相加**</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2\"><span class=\"toc-text\">3.无重复字符的最长字串***</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0\"><span class=\"toc-text\">4.寻找两个正序数组的中位数*****</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">5.最长回文子串***</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">6.Z字形变换****</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC\"><span class=\"toc-text\">7.整数反转**</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi\"><span class=\"toc-text\">8.字符串转换整数(atoi)****</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E5%9B%9E%E6%96%87%E6%95%B0\"><span class=\"toc-text\">9.回文数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">11.盛最多水的容器***</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">12.整数转罗马数字***</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0\"><span class=\"toc-text\">13.罗马数字转整数**</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">14.最长公共前缀</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">15.三数之和****</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">最接近的三数之和****</span></a></li></ol>","author":{"name":"HuangRuYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Github","uid":"cc217f8ad2b16d80f09e9b03836cc169","slug":"Git","date":"2023-01-13T12:21:00.000Z","updated":"2023-02-12T15:40:54.441Z","comments":true,"path":"api/articles/Git.json","keywords":null,"cover":[],"text":"第一章： Git安装查看git版本： git --version 第二章：Git常用命令git config --global user.name 用户名 ： 设置用户签名 git config --global user.email 邮箱 ： 设置用户签名 git init :...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"}],"author":{"name":"HuangRuYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"第一章Vue核心","uid":"966480bfe75397d505c1870990c97c6c","slug":"第一章Vue基础","date":"2023-01-07T12:21:00.000Z","updated":"2023-01-15T06:43:47.216Z","comments":true,"path":"api/articles/第一章Vue基础.json","keywords":null,"cover":[],"text":"Vue核心01_初识Vue:1. 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象 2. root容器里的代码依然符合html规范，只不过混入了特殊的Vue语法 3. root容器里的代码被称为【Vue模板】 4. Vue实例和容器是一一对应的 5. 真实开发中只有...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[],"tags":[{"name":"Vue2","slug":"Vue2","count":1,"path":"api/tags/Vue2.json"}],"author":{"name":"HuangRuYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}