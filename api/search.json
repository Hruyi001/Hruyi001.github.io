[{"id":"0b04aa156cc2381260df63b6ff330e41","title":"Excel","content":"01-Excel作用Excel通常处理以下几件事\n记录整理\n数据计算\n数据分析\n数据展现\n\n高效处理数据，人们面临四大挑战\n数据太多\n计算太累\n需要价值与意义\n需要协作\n\n02-Excel版本保存快捷键Ctrl + s, 另存快捷键F12\n\n03-快速填充快捷键ctrl + E\n选中一列，ctrl + shift + 向下\n\n注意： 自动填充时，左侧一定要有数据\n04-快速分析Ctrl + Q\n\n格式化\n数据条\n色阶\n图标集\n大于  （找到大于某个数值的选项）\n文本包含  （找到包含某个关键词的选项）\n\n图表汇总\n求和\n平均值\n计数\n汇总百分比\n汇总\n求和（侧面生成）\n\n表格迷你图\n折线图\n柱形图\n盈亏\n\n05-Excel数据的正确录入姿势\nTab键：光标移到下一个单元格\nEnter键：光标移到下一行\nShift + Tab：光标移到上一个单元格\nshift + Enter: 光标移到上一行\n数据的筛选可以指明输入格式\nctrl + ; : 今天的日期\nctrl + shift + ; : 今天的时间\n数字前加上英文逗号，变成文本（单元格最多只能输入15位）\nCtrl + Enter： 原位填充，多个单元格填充相同内容\n\n06-如何从网上获取数据\n获取数据：数据-&gt;获取数据-&gt;自其他源-&gt;自网站，输入网址\n定时刷新：数据-&gt;全部刷新-&gt;连接属性-&gt;刷新频率\n\n07-如何处理获取到的数据1. Ctrl + T : 创建超级表\n2. 数据-&gt;来自表格或区域（Power Query编辑器）\n3. Power Query编辑器可以记录每个修改结果\n4. 点击左上角的上载至\n\n08-如何用单元格格式给表格化妆1. 设置单元格格式的快捷键：Ctrl + 1 \n2. 双击右上角，自动适应数据宽度\n\n","slug":"Excel","date":"2023-02-09T12:21:00.000Z","categories_index":"","tags_index":"Excel","author_index":"HuangRuYi"},{"id":"cd85e92a09317c6a4fafc1431f4ed559","title":"Git & maven","content":"第一章： Git安装查看git版本： git --version\n\n第二章：Git常用命令git config --global user.name 用户名    ： 设置用户签名\ngit config --global user.email 邮箱    ： 设置用户签名\ngit init    :    初始化本地库\ngit status    :    查看本地库状态\ngit add    :    添加到暂存区\ngit commit -m &quot;日志信息&quot; 文件名    ：    提交到本地库\ngit reflog    :    查看历史记录\ngit log    :    详细查看历史记录（谁提交）\ngit reset --hard 版本号    ：    版本穿梭\n\n用户签名查看用户签名的方式：\n\n到C:\\Users\\Administrator.gitconfig查看\n命令行：git config –global –list\n\n初始化本地库linux查看隐藏文件： ll -a \n第三章 Git分支操作git branch 分支名    ：    创建分支\ngit branch -v    :    查看分支\ngit checkout 分支名    ：    切换分支\ngit merge 分支名    ：    把指定的分支合并到当前分支上\n解决冲突：hot-fix和master同时被修改，会合并失败\n第四章 Git团队协作机制团队内协作\n跨团队协作\n第五章 Github操作git remote -v        :    查看当前所有远程地址别名\ngit remote add 别名 远程地址    :    起别名\ngit push 别名 分支    ：    推送本地分支上的内容到远程仓库\ngit clone 远程地址    :    将远程仓库的内容克隆到本地\ngit pull 远程库地址别名 远程分支名    :    将远程仓库对于分支最新内容拉下来后与当前分支直接合并\n\n第六章 Idea集成Git\n创建项目\n初始化本地库：点击VCS -&gt; Import into Version Control -&gt; Create Git Repository\n红色文件需要添加到暂存区，右键项目名，点击Git -&gt; Add\n绿色文件需要提交到本地库，右键项目名，点击Git -&gt; Commit File\n\npush是将本地库代码推送到远程库，如果本地库代码跟远程库代码不一致，push操作会被拒绝的，也就是说，要想push成功，先pull拉取远程库代码，将本地代码更新到最新后，再push\n第八章Maven查找maven的依赖：https://mvnrepository.comMaven坐标\n坐标： 用于描述仓库中资源的位置\nMaven坐标组成\ngroupId: 定义当前Maven项目隶属组织名称（通常域名反写，例如：org.mybatis)\nartifactId: 定义当前Maven项目名称（通常是模块名称，例如CRM，SMS）\nversion：定义当前版本号\npackaging: 定义该项目的打包方式\n\n\n坐标作用：使用唯一标识，唯一性定位资源位置，通过该表示可以将资源的识别与下载工作交给机器完成\n\n依赖管理\n依赖传递冲突问题\n\n路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高\n声明优先：当资源再相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的\n特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的\n可选依赖：对外隐藏当前所依赖的资源\n排除依赖：主动断开依赖的资源，被排除的资源无需指定版本\n\n\n依赖范围\n\n依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围\n作用范围\n主程序范围有效（main文件范围内）\n测试范围有效（test文件夹范围内）\n是否参与打包（package指令范围内）\n\n\n\n\n\n生命周期与插件  \n\nMaven对项目构建的生命周期划分为3套* clean：清理工作* default：核心工作，例如，测试，打包，部署等* site: 产生报告，发布站点等\n\nclean生命周期\n\npre-clean\nclean\npost-clean\n\n\ndefault构建生命周期   \n\n\n* 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能\n* 默认maven在各个生命周期上绑定有预设的功能\n* 通过插件可以自定义其他功能 \n\n\n","slug":"Git","date":"2023-01-13T12:21:00.000Z","categories_index":"","tags_index":"Github","author_index":"HuangRuYi"},{"id":"650db86a0bd9ca9738576c6c641f7509","title":"Github使用","content":"Github连接不上\n域名解析网址：http://tool.chinaz.com/dns/  \n找到github.com， github.global.ssl.fastly.net 的IP地址\n修改C:\\Windows\\System32\\Drivers\\etc下的hosts文件\n将上述两个IP地址添加到hosts文件中\n运行ipconfig &#x2F;flushdns清除缓存\n\nhexo命令\nhexo g:　　　　在hexo站点根目录下生成public文件夹\nhexo clean：　　把1中的public文件夹删除\nhexo s：　　　启动服务，默认地址为http://localhost:4000\nhexo d:　　　　部署站点，在本地生成.deploy_git文件夹，并将编译生成后的文件上传至Github\n\n访问博客\n博客访问地址：hruyi001.github.io\nGithub地址：www.github.com/Hruyi\n\n上传博客\nhexo new “First post”  或者  在source&#x2F;_posts目录下创建\n  ---\ntitle: First post\ndate: 2023-01-06 18:33:42\ntags:\n---\n\n\nhexo g\n\nhexo d\n\n\n删除博客\n删除source&#x2F;_posts文件下的markdown文件\n删除.deploy_git文件: rm -rf .deploy_git\n执行hexo clean后，再执行hexo g\n\n解决hexo部署慢的方法\n进入博客仓库，点击setting\n点击左侧Pages, 点击右侧的deployed\n点击re-run all jobs\n\n","slug":"Github","date":"2023-01-13T12:21:00.000Z","categories_index":"","tags_index":"Github","author_index":"HuangRuYi"},{"id":"18fe105d7c8cde2f9eebd0e775b3d96c","title":"LeetCode 1-50","content":"1.两数之和*哈希表插入和查询操作复杂度都是0（1）\n\nclass Solution &#123;\npublic:\n    unordered_map&lt;int,int&gt;p;\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123; \n            int r &#x3D; target - nums[i];\n            if(p.count(r)) return &#123;p[r], i&#125;;\n            p[nums[i]] &#x3D; i;\n        &#125; \n        return &#123;&#125;;\n    &#125;\n&#125;;\n2.两数相加**两个链表按逆序相加\n\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n      ListNode *p &#x3D; l1, *q &#x3D; l2;\n      ListNode *pre &#x3D; new ListNode(), *r &#x3D; pre;\n      int t &#x3D; 0, a , b;\n      while(p || q || t) \n      &#123;\n          a &#x3D; p ? p-&gt;val : 0;\n          b &#x3D; q ? q-&gt;val : 0;\n          if(p) p &#x3D; p-&gt;next;\n          if(q) q &#x3D; q-&gt;next;\n          t +&#x3D; a + b;\n          r-&gt;next &#x3D; new ListNode(t % 10);\n          t &#x2F;&#x3D; 10;\n          r &#x3D; r-&gt;next;\n      &#125;\n      return pre-&gt;next;\n    &#125;\n&#125;;\n3.无重复字符的最长字串***双指针扫描O(n), 定义两个指针i,j(i&lt;=j), [i, j]\n1. 指针j向后移一位，同时将哈希表s[j]的计数加1\n2. 假设j移动前的区间[i,j]中没有重复字符，则j移动后，只有s[j]可能出现2次，因此我们不断向后移动i, 直至区间[i,j]中s[j]的个数为1\n\n   注意字串和子序列的区别：字串一定是连续的一段， 子序列不一定是连续的一段，但下标是递增的\nint lengthOfLongestSubstring(string s) &#123; \n       unordered_map&lt;char, int&gt; p;\n       int res &#x3D; 0; \n       for(int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;\n           p[s[i]] ++;         &#x2F;&#x2F; j可以向前移动p[s[i]] - 1步\n           while(p[s[i]] &gt; 1) p[s[j++]] --;    &#x2F;&#x2F;遇到连续重复的序列，j要右移   \n           res &#x3D; max(res, i - j + 1);\n       &#125;\n       return res;\n   &#125;\n\n4.寻找两个正序数组的中位数*****class Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; \n        int tot &#x3D; nums1.size() + nums2.size();\n        if(tot % 2 &#x3D;&#x3D; 0) &#123;      &#x2F;&#x2F;序列长度为偶数\n            int left &#x3D; find(nums1, 0, nums2, 0, tot &#x2F; 2);\n            int right &#x3D; find(nums1, 0, nums2, 0, tot &#x2F; 2 + 1);\n            return (left + right) &#x2F; 2.0;\n        &#125;\n        else \n            return find(nums1, 0, nums2, 0, tot &#x2F; 2 + 1);\n    &#125; \n    &#x2F;&#x2F;找到nums1从i开始, nums2从j开始，第k大的元素\n    int find(vector&lt;int&gt; &amp;nums1, int i, vector&lt;int&gt; &amp;nums2, int j, int k) &#123;\n        &#x2F;&#x2F;nums1可用的序列长度大于nums2可用的序列长度\n        if(nums1.size() - i &gt; nums2.size() - j) return find(nums2, j, nums1, i, k);\n        if(k &#x3D;&#x3D; 1) &#123;        &#x2F;&#x2F;找到第一大的元素\n            if(nums1.size() &#x3D;&#x3D; i) return nums2[j];\n            else    return min(nums1[i], nums2[j]);\n        &#125;\n        &#x2F;&#x2F;nums1可用序列为空\n        if(nums1.size() &#x3D;&#x3D; i) return nums2[j + k - 1];\n        &#x2F;&#x2F;si为nums1的可能到达的新位置，向右移动k&#x2F;2\n        int si &#x3D; min((int)nums1.size(), i + k &#x2F; 2), sj &#x3D; j + k - k &#x2F; 2;\n        if(nums1[si - 1] &lt; nums2[sj - 1])   &#x2F;&#x2F;nums1中前k&#x2F;2个元素都小于num2的第k&#x2F;2位置的值，\n            return find(nums1, si, nums2, j, k - (si - i));     \n            &#x2F;&#x2F;在nums1的[si,nums1.size() - 1], nums2的[j, nums2.size() - 1]的范围内找第k - (si - i)个元素\n            &#x2F;&#x2F;即等价于在nums1[i, nums1.size() - 1], nums2在[j, nums2.size() - 1]内找第K个元素\n        else    \n            return find(nums1, i, nums2, sj, k - (sj - j));\n    &#125;\n&#125;;\n5.最长回文子串***class Solution &#123;\npublic:\n    string longestPalindrome(string s) &#123;\n        string res;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            &#x2F;&#x2F;回文串为偶数长度\n            int l &#x3D; i - 1, r &#x3D; i + 1;\n            while(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;     \n            if(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);    &#x2F;&#x2F;从 l+1位开始，长度为r-l-1的字串\n            &#x2F;&#x2F;回文串为奇数长度\n            l &#x3D; i, r &#x3D; i + 1;\n            while(l &gt;&#x3D; 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] &#x3D;&#x3D; s[r]) l--, r++;\n            if(res.size() &lt; r - l - 1) res &#x3D; s.substr(l + 1, r - l - 1);\n        &#125;\n        return res;\n    &#125;\n&#125;;\n6.Z字形变换****\n找规律：第一行和最后一行是公差为2n - 2的等差数列以i为起始点 ，第二行到倒数第二行也一样，但斜线上是2n - 2 -i为起始点公差为2*n - 2的等差数列class Solution &#123;\npublic:\n    string convert(string s, int n) &#123;\n        if(n &#x3D;&#x3D; 1) return s;\n        string res;\n        for(int i &#x3D; 0; i &lt; n; i++) &#123;\n            if(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) &#123;\n                for(int j &#x3D; i; j &lt; s.size(); j +&#x3D; 2 * n - 2) \n                    res +&#x3D; s[j];\n            &#125;\n            else &#123;\n                for(int j &#x3D; i, k &#x3D; 2 * n - 2 - i; j &lt; s.size() || k &lt;s.size(); j +&#x3D; 2 * n - 2, k +&#x3D; 2*n -2) &#123;\n                    if(j &lt; s.size()) res +&#x3D; s[j];\n                    if(k &lt; s.size()) res +&#x3D; s[k];\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n2. 模拟Z路径: i = 0 或 i = n - 1时，变换路径方向\n\nclass Solution &#123;\npublic:\n    string convert(string s, int n) &#123; \n        if(n &#x3D;&#x3D; 1) return s;\n        vector&lt;string&gt; v;\n        v.resize(n);\n        int flag &#x3D; -1;\n        int i &#x3D; 0;\n        for(auto x : s) &#123;\n            if(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; n - 1) \n                flag &#x3D; - flag;\n            v[i] +&#x3D; x;\n            i +&#x3D; flag;\n        &#125;\n        for(int i &#x3D; 1; i &lt; n; i++) \n            v[0] +&#x3D; v[i];\n        return v[0];\n    &#125;\n&#125;;\n\n7.整数反转**class Solution &#123;\npublic:\n    int reverse(int x) &#123;\n        int res &#x3D; 0;\n        while(x) &#123; \n&#x2F;&#x2F;     res * 10 + x % 10 &gt; INT_MAX\n            if(res &gt; 0 &amp;&amp; res &gt; (INT_MAX - x % 10) &#x2F; 10) return 0;\n&#x2F;&#x2F;     res * 10 + x % 10 &lt; INT_MIN\n            if(res &lt; 0 &amp;&amp; res &lt; (INT_MIN - x % 10) &#x2F; 10) return 0;\n            res &#x3D; 10 * res + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n8.字符串转换整数(atoi)****class Solution &#123;\npublic:\n    int myAtoi(string s) &#123;\n        int k &#x3D; 0;\n        while(k &lt; s.size() &amp;&amp; s[k] &#x3D;&#x3D; &#39; &#39;) k++;     &#x2F;&#x2F;跳过前导空格\n        int minus &#x3D; 1;\n        if(s[k] &#x3D;&#x3D; &#39;-&#39;) minus &#x3D; -1, k++;       &#x2F;&#x2F;负数\n        else if(s[k] &#x3D;&#x3D; &#39;+&#39;) k++;               &#x2F;&#x2F;正数\n        int res &#x3D; 0;\n        while(k &lt; s.size() &amp;&amp; s[k] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[k] &lt;&#x3D; &#39;9&#39;) &#123;         &#x2F;&#x2F;非数字字符或者末尾时，退出\n            int x &#x3D; s[k] - &#39;0&#39;; \n            if(minus &gt; 0 &amp;&amp; res &gt; (INT_MAX - x) &#x2F; 10)    return INT_MAX;    &#x2F;&#x2F;正溢出\n            if(minus &lt; 0 &amp;&amp; -res &lt; (INT_MIN + x) &#x2F; 10)   return INT_MIN;    &#x2F;&#x2F;负溢出\n            if(- 10 * res - x &#x3D;&#x3D; INT_MIN)    return INT_MIN;        &#x2F;&#x2F;res为正数时，存在等于最小负数整数的情况     \n            res &#x3D; 10 * res + x;\n            k++;\n        &#125;\n        return minus * res;     &#x2F;&#x2F;加上符号\n    &#125;\n&#125;;\n9.回文数*class Solution &#123;\npublic:\n    bool isPalindrome(int x) &#123;\n        if( x &lt; 0) return 0;\n        long long res &#x3D; 0, n &#x3D; x;\n        while(x) &#123;\n            res &#x3D; 10 * res + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res &#x3D;&#x3D; n;\n    &#125;\n&#125;;\n&#96;&#96;&#96;&#96;\n### 10.正则表达式匹配[*****](https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;regular-expression-matching&#x2F;description&#x2F;)\n&#96;&#96;&#96; c++\nclass Solution &#123;\n非递归：\npublic:\n    bool isMatch(string s, string p) &#123;\n        int n &#x3D; s.size(), m &#x3D; p.size();\n        s &#x3D; &#39; &#39; + s;\n        p &#x3D; &#39; &#39; + p;\n        vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));\n        f[0][0] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) \n            for(int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;\n                if(j + 1 &lt;&#x3D; m &amp;&amp; p[j + 1] &#x3D;&#x3D; &#39;*&#39;) continue;         \n                &#x2F;&#x2F;a*是组合在一起的被归纳在else if(p[j] &#x3D;&#x3D;&#39;*&#39;)\n                else if(i &amp;&amp; p[j] !&#x3D; &#39;*&#39;)       &#x2F;&#x2F;s不为空，p[j]是有效字符\n                    f[i][j] &#x3D; f[i - 1][j - 1] &amp;&amp; (s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;.&#39;);\n                else if(p[j] &#x3D;&#x3D; &#39;*&#39;)        &#x2F;&#x2F;p[j]与p[j - 1]组合使用，\n                    f[i][j] &#x3D; f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;);\n                    &#x2F;&#x2F;f[i][j - 2]: *表示零个p[j - 1]的情况 或者 s[0 ~ i]可以匹配p[0 ~ j - 2]\n                    &#x2F;&#x2F;f[i - 1][j]表示s[0 ~ i - 1]与p[0 ~ j]所匹配，s[i]又与p[0 ~ j]所匹配 &#x3D;》\n                    &#x2F;&#x2F;f[i - 1][j]： s[0 ~ i] 与 p[0 ~ j]匹配\n            &#125;\n        return f[n][m];\n    &#125;\n&#125;;\n\n11.盛最多水的容器***class Solution &#123;\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) &#123;\n        int i &#x3D; 0, j &#x3D; height.size() - 1;\n        int res &#x3D; 0;\n        while(i &lt; j) &#123;\n            res &#x3D; max(res, (j - i) * min(height[i], height[j]));\n            if(height[i] &lt; height[j]) i++;        \n            &#x2F;&#x2F;容器左端高度小于右端高度，如果存在其他的最大值，那么左端右移\n            else j--;\n            &#x2F;&#x2F;容器左端高度大于右端高度，如果存在其他的最大值，那么右端左移\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n12.整数转罗马数字***class Solution &#123;\npublic:\n    string intToRoman(int num) &#123;\n        int values[] &#x3D; &#123;\n            1000,\n            900, 500, 400, 100,\n            90, 50, 40, 10,\n            9, 5, 4, 1\n        &#125;;\n        string s[] &#x3D; &#123;\n                &quot;M&quot;,\n                &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;,\n                &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;,\n                &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;\n        &#125;;\n        string res;\n        for(int i &#x3D; 0; i &lt; 13; i++) &#123;\n            while(num &gt;&#x3D; values[i]) &#123;\n                num -&#x3D; values[i];\n                res +&#x3D; s[i];\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n13.罗马数字转整数**class Solution &#123;\npublic:\n    int romanToInt(string s) &#123;\n        unordered_map&lt;char,int&gt; hash;\n        hash[&#39;I&#39;] &#x3D; 1, hash[&#39;V&#39;] &#x3D; 5;\n        hash[&#39;X&#39;] &#x3D; 10, hash[&#39;L&#39;] &#x3D; 50;\n        hash[&#39;C&#39;] &#x3D; 100, hash[&#39;D&#39;] &#x3D; 500;\n        hash[&#39;M&#39;] &#x3D; 1000;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if(i + 1 &lt; s.size() &amp;&amp; hash[s[i]] &lt; hash[s[i + 1]]) &#123;\n                res -&#x3D; hash[s[i]];\n            &#125;\n            else res +&#x3D; hash[s[i]];\n            cout&lt;&lt;res&lt;&lt;endl;\n        &#125;\n        return res;\n    &#125;   \n&#125;;\n14.最长公共前缀*class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        string s;\n        int k &#x3D; INT_MAX;\n        for(int i &#x3D; 0; i &lt; strs.size(); i++)\n            k &#x3D; min(k, (int)strs[i].size());\n        if(!k) return s;\n        for(int i &#x3D; 0; i &lt; k; i++) &#123;\n            bool flag &#x3D; 1;\n            for(int j &#x3D; 1; j &lt; strs.size(); j++)\n                if(strs[j][i] !&#x3D; strs[0][i]) &#123;\n                    flag &#x3D; 0;\n                    break;\n                &#125;\n            if(flag) s +&#x3D; strs[0][i];\n            else break;\n        &#125;\n        return s;\n    &#125;\n&#125;;\n15.三数之和****class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        sort(nums.begin(), nums.end());     &#x2F;&#x2F;对数组进行排序\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            &#x2F;&#x2F;题目要求不要重复的三元组\n            if(i &amp;&amp; nums[i] &#x3D;&#x3D; nums[i -1]) continue;\n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                &#x2F;&#x2F;跳过重复的三元组\n                if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;\n                &#x2F;&#x2F;确定k的位置了，跳过不满足nums[i] + nums[j] + nums[k] &gt; 0\n                while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; 0) k--;\n                if(nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0) &#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n\n最接近的三数之和****class Solution &#123;\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;\n        sort(nums.begin(), nums.end());\n        pair&lt;int, int&gt; res(INT_MAX, INT_MAX);\n        for(int i &#x3D; 0; i &lt; nums.size(); i++) \n            for(int j &#x3D; i + 1, k &#x3D; nums.size() - 1; j &lt; k; j++) &#123;\n                while(k - 1 &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - 1] &gt;&#x3D; target) k--;\n                int s &#x3D; nums[i] + nums[j] + nums[k];\n                res &#x3D; min(res, make_pair(abs(s - target), s));\n                if(k - 1 &gt; j) &#123;\n                    s &#x3D; nums[i] + nums[j] + nums[k - 1];\n                    res &#x3D; min(res, make_pair(target - s, s));\n                &#125;\n            &#125;\n        return res.second;\n    &#125;\n&#125;;","slug":"LeetCode","date":"2023-01-08T12:21:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"HuangRuYi"},{"id":"966480bfe75397d505c1870990c97c6c","title":"第一章Vue核心","content":"Vue核心01_初识Vue:1. 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象\n2. root容器里的代码依然符合html规范，只不过混入了特殊的Vue语法\n3. root容器里的代码被称为【Vue模板】\n4. Vue实例和容器是一一对应的\n5. 真实开发中只有一个Vue实例，并且会配合着组件一起使用\n6. &#123;&#123;xxx&#125;&#125;中的xxxx要写js表达式，且xxx可以自动读取到data中的所有属性\n7. 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新\n\n&lt;!-- 准备一个容器 --&gt;\n   &lt;div id &#x3D; &quot;root&quot;&gt;\n       &lt;h1&gt; Hello, &#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n   &lt;&#x2F;div&gt; \n   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n       Vue.config.productionTip &#x3D; false\n\n       new Vue(&#123;\n           el: &#39;#root&#39;,     &#x2F;&#x2F;el用于指定当前Vue实例为哪个容器服务\n           data: &#123;         &#x2F;&#x2F;data中用于存储数据，数据供el所指定的容器去使用，\n               name : &#39;张三&#39;   \n           &#125;\n       &#125;)\n   &lt;&#x2F;script&gt; \n\n02_Vue模板语法1. 插值语法：\n    功能： 用于解析标签体内容\n    写法： &#123;&#123;xxx&#125;&#125;, xxx是js表达式，且可以直接读取到data中的所有属性\n2. 指令语法：\n    功能： 用于解析标签（包括：标签属性，标签体内容，绑定时间\n    举例： v-bind:href = &quot;xxx&quot; 或 简写为:href = &quot;xxx&quot;, xxx同样要写js表达式，且可以直接读取到data所有属性\n\n &lt;div id &#x3D; &quot;root&quot;&gt;\n    &lt;h1&gt; 插值语法 &lt;&#x2F;h1&gt; \n    &lt;h3&gt; 你好，&#123;&#123;name&#125;&#125;&lt;&#x2F;h3&gt;  \n    &lt;h1&gt; 指令语法 &lt;&#x2F;h1&gt;   \n    &lt;a :href&#x3D;&quot;school.url.toUpperCase()&quot;&gt;百度一下啊&#123;&#123;school.name&#125;&#125;&lt;&#x2F;a&gt;\n    &lt;a :href&#x3D;&quot;Date.now&quot;&gt;&#123;&#123;school.name&#125;&#125;&lt;&#x2F;a&gt;\n    \n&lt;&#x2F;div&gt; \n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false \n    new Vue(&#123;\n        el: &#39;#root&#39;,     &#x2F;&#x2F;el用于指定当前Vue实例为哪个容器服务\n        data: &#123;         &#x2F;&#x2F;data中用于存储数据，数据供el所指定的容器去使用，\n            name : &#39;张三&#39;,\n            school: &#123;\n                name: &#39;尚硅谷&#39;,\n                url: &#39;http:&#x2F;&#x2F;www.baidu.com&#39;\n            &#125;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt; \n\n03_数据绑定Vue中有2种数据绑定方式\n   1. 单向绑定(v-bdin): 数据只能从data流向页面\n   2. 双向绑定(v-model): 数据不仅能从data流向页面，还可以从页面流向data\n\n注意：  \n**1.双向绑定一般应用在表单元素上（如：input, select)**  \n**2. v-model:value可以简写为v-model， 因为v-model默认收集的就是value值**\n\n&lt;div id &#x3D; &quot;root&quot;&gt;\n    &lt;!-- 普通写法 --&gt;\n    &lt;!-- 单向数据绑定: &lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;name&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n    双向数据绑定: &lt;input type&#x3D;&quot;text&quot; v-model:value&#x3D;&quot;name&quot;&#x2F;&gt; --&gt;\n    &lt;!-- 简写 --&gt;\n    单向数据绑定: &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;name1&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n    双向数据绑定: &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name2&quot;&#x2F;&gt;\n&lt;&#x2F;div&gt; \n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false   \n    new Vue(&#123;\n        el: &#39;#root&#39;,\n        data: &#123;\n            name1: &#39;尚硅谷1&#39;,\n            name2: &#39;尚硅谷2&#39;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt; \n\n04_el与data的两种写法* el的两种写法  \n    * new Vue时配置el属性\n    * 先创建Vue实例，随后再通过vm.$mount(&#39;#root&#39;)指定el的值\n&lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt; 你好，&#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;div&gt;\n&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    Vue.config.productionTip &#x3D; false\n    const v &#x3D; new Vue(&#123; \n        &#x2F;&#x2F;el: &#39;#root&#39;,      &#x2F;&#x2F;第一种写法\n        data: &#123;\n            name: &#39;尚硅谷&#39;\n        &#125;\n    &#125;)\n    console.log(v);\n    setTimeout(() &#x3D;&gt; &#123;\n        v.$mount(&#39;#root&#39;)       &#x2F;&#x2F;第二种写法\n    &#125;, 1000);\n&lt;&#x2F;script&gt;\n\n* data的两种写法\n* 对象式\n* 函数式  \n**如何选择： 目前哪种写法都可以，以后学习组件时，data必须使用函数式，否则会报错**        \n    &lt;script&gt;\n    Vue.config.productionTip &#x3D; false\n    new Vue(&#123; \n        el: &#39;#root&#39;,      &#x2F;&#x2F;第一种写法\n        &#x2F;&#x2F;data的第一种写法：对象式\n        &#x2F;* data: &#123;\n            name: &#39;尚硅谷&#39;\n        &#125; *&#x2F;\n        \n        &#x2F;&#x2F; data的第二种写法：函数式\n        data()&#123;\n            console.log(&#39;@@@&#39;, this)\n            return &#123;\n                name:&#39;尚硅谷&#39;\n            &#125;\n        &#125;\n    &#125;) \n&lt;&#x2F;script&gt;\n\n* 一个重要的原则：    \n    **由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了**\n    \n\n05_MVVM1. M: 模型(Model)\n2. V: 视图(View): 模块\n3. VM: 视图模型(ViewModel)： Vue实例对象\n观察发现：\n    1. data中所有的属性，最后都出现在了vm上\n    2. vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用  \n\n \n06_数据代理回顾Object.defineproperty方法    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let number &#x3D; 20\n    let person &#x3D; &#123;\n        name:&#39;张三&#39;,\n        sex:&#39;男&#39; \n    &#125; \n    Object.defineProperty(person, &#39;age&#39;, &#123;\n      &#x2F;*   value:18,\n        enumerable: true,    &#x2F;&#x2F;控制属性是否可以枚举，默认值是false\n        writable: true,     &#x2F;&#x2F;控制属性是否可以被修改，默认值是false\n        configurable: true  &#x2F;&#x2F; 控制属性是否可以被删除，默认值是false *&#x2F;\n        get:function() &#123;\n            console.log(&#39;有人读取age属性了&#39;)\n            return number;\n        &#125;,\n        set:function(value) &#123;\n            console.log(&#39;有人修改age属性&#39;)\n            number &#x3D; value\n        &#125;\n    &#125;) \n    for(let key in person) \n        console.log(&#39;@&#39;, person[key]);\n    console.log(person);\n\n&lt;&#x2F;script&gt;\n\n何为数据代理&lt;!-- 用Obj2操纵obj的x属性 --&gt;\n &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let obj &#x3D; &#123;x:100&#125;\n    let obj2 &#x3D; &#123;y:200&#125;\n\n    Object.defineProperty(obj2, &#39;x&#39;, &#123;\n        get() &#123;\n            return obj.x\n        &#125;,\n        set(value) &#123;\n            obj.x &#x3D; value\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\nVue中的数据代理1. Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写)\n2. Vue中的数据代理好处： 更加方便的操作data中的数据\n3. 基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上，为每一个添加到vm上的属性，都指定一个getter/setter。在getter/setter操作（读/写)data中对应的\n\n\n07_事件处理1.事件的基本使用1. 使用v-on:xxx 或 @xxx绑定事件，其中xxx是时间名\n2. 事件的回调需要配置在methods对象中，最终会在vm上\n3. methods中配置的函数，不要用箭头函数，否则this就不是vm了\n4. methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件\n5. @click=&quot;demo&quot; 和@click=&quot;demo($event)&quot; 效果一致，但后者可以传参\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n        &lt;h1&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;&#x2F;h1&gt;\n        &lt;button @click&#x3D;&quot;showInfo1&quot;&gt; 点我提示信息1(不传参)&lt;&#x2F;button&gt;&lt;&#x2F;br&gt;\n        &lt;button @click&#x3D;&quot;showInfo2(453, $event)&quot;&gt; 点我提示信息2(传参)&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                name: &#39;尚硅谷&#39;\n            &#125;,\n            methods: &#123;\n                showInfo1() &#123; \n                    alert(&quot;同学你好！&quot;)\n                &#125;,\n                showInfo2(number, event) &#123; \n                    console.log(number, event)\n                &#125;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n2.事件修饰符1. prevent: 阻止默认事件（常用）\n2. stop: 阻止事件冒泡（常用）\n3. once: 事件只触发一次（常用）\n4. capture: 事件只触发一次（常用）\n5. self: 只有event.target是当前操作的元素时才触发事件\n6. passive: 事件的默认行为立即执行，无需等待事件回调执行完毕\n\n    &lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;style&gt;\n    *&#123;\n        margin-top: 20px;\n    &#125;\n    .demo1&#123;\n        height: 50px;\n        background-color: skyblue;\n    &#125;\n    .box1&#123;\n        padding: 5px;\n        background-color: skyblue;\n    &#125;\n    .box2&#123;\n        padding: 5px;\n        background-color: orange;\n    &#125;\n    .list&#123;\n        width: 200px;\n        height: 200px;\n        background-color: peru;\n        overflow: auto;\n    &#125;\n    li&#123;\n        height: 100px;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n        &lt;h1&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;&#x2F;h1&gt; \n        &lt;!-- 阻止默认事件（常用） --&gt;\n        &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.atguigu.com&quot; @click.prevent&#x3D;&quot;showInfo&quot;&gt;点我提示息&lt;&#x2F;a&gt; \n        &lt;!-- 阻止事件冒泡（常用） --&gt;\n        &lt;div class &#x3D; &quot;demo1&quot; @click&#x3D;&quot;showInfo&quot;&gt;\n            &lt;button @click.stop&#x3D;&quot;showInfo&quot;&gt;点我提示信息&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n        &lt;!-- 事件只触发一次（常用） --&gt;\n        &lt;button @click.once&#x3D;&quot;showInfo&quot;&gt;点我提示信息&lt;&#x2F;button&gt;&lt;&#x2F;button&gt;\n        &lt;!-- 使用事件的捕获模式 --&gt;\n        &lt;div class&#x3D;&quot;box1&quot; @click.capture&#x3D;&quot;showMsg(1)&quot;&gt;\n            div1\n            &lt;div class&#x3D;&quot;box2&quot; @click&#x3D;&quot;showMsg(2)&quot;&gt;\n                div2\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;!-- 只有event.target是当前操作的元素时才触发事件 --&gt;\n        &lt;div class &#x3D; &quot;demo1&quot; @click.self&#x3D;&quot;showInfo&quot;&gt;\n            &lt;button @click&#x3D;&quot;showInfo&quot;&gt;点我提示信息&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n        &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行 --&gt;\n        &lt;ul @wheel.passive&#x3D;&quot;demo&quot; class&#x3D;&quot;list&quot;&gt;\n            &lt;li&gt;1&lt;&#x2F;li&gt;\n            &lt;li&gt;2&lt;&#x2F;li&gt; \n            &lt;li&gt;3&lt;&#x2F;li&gt;\n            &lt;li&gt;4&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;, \n            data: &#123;\n                name: &#39;尚硅谷&#39;\n            &#125;,\n            methods: &#123; \n                showInfo(e) &#123; \n                    console.log(e.target)\n                &#125;,\n                showMsg(msg) &#123;\n                    console.log(msg)\n                &#125;,\n                demo() &#123;\n                    for(let i &#x3D; 0; i &lt; 100000; i++) &#123;\n                        console.log(&#39;#&#39;)\n                    &#125;\n                    console.log(&#39;累坏了&#39;)\n                &#125;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt; \n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt; \n\n3.键盘事件   1. Vue中常用的按键别名 \n       * 回车  =&gt; enter\n       * 删除  =&gt; delete\n       * 退出  =&gt; esc\n       * 换行  =&gt; tab\n       * 上    =&gt; up\n       * 下    =&gt; down\n       * 左    =&gt; left\n       * 右    =&gt; right\n   2. Vue未提供别名的按键，可以使用按键原始的Key值去绑定，但注意要转为kebab-case（短横线命名）\n   3. 系统修饰键（用法特殊）：ctrl, alt, shift, meta\n   4. 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n   5. 配合keydown使用： 正常触发事件 \n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.ctrl.y&#x3D;&quot;showInfo&quot;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    Vue.config.productionTip &#x3D; false\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;尚硅谷&#39;\n        &#125;,\n        methods: &#123;\n            showInfo(e) &#123;\n                console.log(e.key, e.keyCode)\n                &#x2F;&#x2F; console.log(e.target.value)\n            &#125;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n08_计算属性姓名案例_methods实现&lt;div id&#x3D;&quot;app&quot;&gt; \n    姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n    名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n    全名：&lt;span&gt;&#123;&#123;fullName()&#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    Vue.config.productionTip &#x3D; false\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            firstName: &#39;张&#39;,\n            lastName: &#39;三&#39;\n        &#125;,\n        methods: &#123; \n                fullName() &#123;\n                    return this.firstName + &#39;-&#39; + this.lastName;\n                &#125;\n            &#125; \n    &#125;)\n&lt;&#x2F;script&gt;\n姓名案例_计算属性实现1. 定义：要用的属性不存在，要通过已有属性计算得来\n2. 原理： 底层借助了Object.defineproperty方法提供的getter和setter\n3. get函数什么时候执行？\n   1. 初次读取时会执行一次\n   2. 当依赖的数据发生改变时会被再次调用\n4. 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便\n5. 备注：\n   1. 计算属性最终会出现在vm上，直接读取使用即可\n   2. 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时以来的数据发生改变\n\n&lt;div id&#x3D;&quot;app&quot;&gt; \n        姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        校名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        \n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                firstName: &#39;张&#39;,\n                lastName: &#39;三&#39;,\n                name: &#39;尚硅谷&#39;\n            &#125;,\n            computed: &#123;\n                fullName: &#123;\n                    get() &#123;\n                        console.log(&quot;@@@@@@@@@@&quot;)\n                        return this.firstName + &#39;-&#39; + this.lastName;\n                    &#125;,\n                    set(value) &#123;\n                        const arr &#x3D; value.split(&#39;-&#39;)\n                        this.firstName &#x3D; arr[0]\n                        this.lastName &#x3D; arr[1]\n                    &#125;\n                &#125;\n            &#125;   \n        &#125;)\n姓名案例_计算属性简写&lt;div id&#x3D;&quot;app&quot;&gt; \n    姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n    名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt; \n    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt; \n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    Vue.config.productionTip &#x3D; false\n    const vm &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            firstName: &#39;张&#39;,\n            lastName: &#39;三&#39; \n        &#125;,\n        computed: &#123;     &#x2F;&#x2F;只有get方法\n            fullName() &#123;\n                return this.firstName + &#39;-&#39; + this.lastName;\n            &#125;\n        &#125;   \n    &#125;)\n&lt;&#x2F;script&gt;\n09_监视属性天气案例_监视属性监视属性watch:\n    1. 当被监视属性变化时，回调函数自动调用，进行相关操作\n    2. 监视的属性必须存在，才能进行监视\n    3. 监视的两种写法：\n       1. new Vue时传入watch配置\n       2. 通过vm.$watch监视\n\n&lt;div id&#x3D;&quot;app&quot;&gt;  \n     &lt;h2&gt;今天天气很好&#123;&#123;info&#125;&#125;，&#123;&#123;x&#125;&#125;&lt;&#x2F;h2&gt;  \n     &lt;button @click&#x3D;&quot;changeWeather&quot;&gt;切换天气&lt;&#x2F;button&gt;\n &lt;&#x2F;div&gt;\n \n &lt;script&gt;\n     Vue.config.productionTip &#x3D; false\n     const vm &#x3D; new Vue(&#123;\n         el: &#39;#app&#39;,\n         data: &#123;\n             isHot: true,\n             x : 0\n         &#125;,\n         computed: &#123;     \n             info() &#123;\n                 return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;\n             &#125;\n         &#125;,\n         methods: &#123;\n             changeWeather() &#123;\n                 this.isHot &#x3D; !this.isHot\n                 this.x ++\n             &#125;\n         &#125;,\n         &#x2F;&#x2F; watch: &#123;\n         &#x2F;&#x2F;     isHot: &#123;\n         &#x2F;&#x2F;         immediate: true,    &#x2F;&#x2F;初始化时让handler调用一下\n         &#x2F;&#x2F;         handler(newValue, oldValue)&#123;        &#x2F;&#x2F;handler什么时候调用，当isHot发生改变时\n         &#x2F;&#x2F;             console.log(&#39;isHot被修改了&#39; ,newValue,  oldValue)\n         &#x2F;&#x2F;         &#125;\n         &#x2F;&#x2F;     &#125;\n         &#x2F;&#x2F; &#125; \n     &#125;)\n     vm.$watch(&#39;isHot&#39;, &#123;\n         immediate: true,    &#x2F;&#x2F;初始化时让handler调用一下\n                 handler(newValue, oldValue)&#123;        &#x2F;&#x2F;handler什么时候调用，当isHot发生改变时\n                     console.log(&#39;isHot被修改了&#39; ,newValue,  oldValue)\n                 &#125;\n     &#125;)\n &lt;&#x2F;script&gt;\n天气案例_深度监视\n深度监视:\nVue中的watch默认不检测对象内部值的改变\n配置deep:true可以监测对象内部值改变（多层）\n\n\n备注：\nVue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\n使用watch时根据数据的具体结构，决定是否采用深度监视&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n    \n    &lt;div id&#x3D;&quot;app&quot;&gt;  \n        &lt;h2&gt;今天天气很好&#123;&#123;info&#125;&#125;&lt;&#x2F;h2&gt;  \n        &lt;button @click&#x3D;&quot;changeWeather&quot;&gt;切换天气&lt;&#x2F;button&gt;\n        &lt;hr&#x2F;&gt;\n        &lt;h3&gt;a的值是:&#123;&#123;numbers.a&#125;&#125;&lt;&#x2F;h3&gt;\n        &lt;button @click&#x3D;&quot;numbers.a++&quot;&gt; 点我让a+1&lt;&#x2F;button&gt;\n        &lt;hr&#x2F;&gt;\n        &lt;h3&gt;b的值是:&#123;&#123;numbers.b&#125;&#125;&lt;&#x2F;h3&gt;\n        &lt;button @click&#x3D;&quot;numbers.b++&quot;&gt; 点我让b+1&lt;&#x2F;button&gt;\n        &lt;hr&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;numbers&#x3D;&#123;a:100, b: 23242&#125;&quot;&gt; 点我让numbers变化&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                isHot: true,\n                numbers: &#123;\n                    a:1,\n                    b:1\n                &#125;\n            &#125;,\n            computed: &#123;     \n                info() &#123;\n                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;\n                &#125;\n            &#125;,\n            methods: &#123;\n                changeWeather() &#123;\n                    this.isHot &#x3D; !this.isHot\n                    this.x ++\n                &#125;\n            &#125;,\n            watch: &#123;\n             &#x2F;*    isHot: &#123;\n                    immediate: true,    &#x2F;&#x2F;初始化时让handler调用一下\n                    handler(newValue, oldValue)&#123;        &#x2F;&#x2F;handler什么时候调用，当isHot发生改变时\n                        console.log(&#39;isHot被修改了&#39; ,newValue,  oldValue)\n                    &#125;\n                &#125;,\n                numbers: &#123;\n                    deep: true,\n                    handler() &#123;\n                        console.log(&#39;nunmbers被修改了&#39;)\n                    &#125;\n                &#125; *&#x2F;\n                &#x2F;&#x2F;简写：\n                isHost(newValue, oldValue) &#123;\n                    console.log(&#39;isHot被修改了&#39;, newValue, oldValue)\n                &#125;\n            &#125; \n        &#125;)\n        &#x2F;* vm.$watch(&#39;isHot&#39;, &#123;\n            immediate: true,    &#x2F;&#x2F;初始化时让handler调用一下\n                    handler(newValue, oldValue)&#123;        &#x2F;&#x2F;handler什么时候调用，当isHot发生改变时\n                        console.log(&#39;isHot被修改了&#39; ,newValue,  oldValue)\n                    &#125;\n        &#125;) *&#x2F;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt; \n          \n\n\n\ncomputed 与 watch的区别1. computed能完成的功能，watch都可以完成\n2. watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作  \n\n两个重要的小原则：    1. 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象    2. 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等，Promise的回调函数），最好写成箭头函数，这样this的指向才是vm或组件实例对象\n&lt;div id&#x3D;&quot;app&quot;&gt; \n        姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;\n        名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &lt;br&#x2F;&gt;&lt;br&#x2F;&gt; \n        全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt; \n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                firstName: &#39;张&#39;,\n                lastName: &#39;三&#39;,\n                fullName: &#39;张-三&#39;\n            &#125;,\n            watch: &#123;\n                &#x2F;&#x2F;firstName与lastName变化，fullName也要变 \n               &#x2F;*  firstName(val) &#123;\n                    this.fullName &#x3D; val + &#39;-&#39; + this.lastName;\n                &#125;, *&#x2F;\n                &#x2F;&#x2F; 等一秒之后再显示全名\n                firstName(val) &#123;\n                    setTimeout(() &#x3D;&gt; &#123;\n                        this.fullName &#x3D; val + &#39;-&#39; + this.lastName;\n                    &#125;, 1000)\n                &#125;,\n                lastName(val) &#123;\n                    this.fullName &#x3D; this.firstName +\n                &#125;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n\n10_绑定样式1. class样式写法 :class=&quot;xxx&quot; xxx可以是字符串，对象，数组\n   1. 字符串写法适用于：类名不确定，要动态获取\n   2. 对象写法适用于：要绑定多个样式，个数不确定\n   3. 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用\n2. style样式\n   1. :style=&quot;&#123;fontSize: xxx&#125;&quot; 其中xxx是动态值\n   2. :style=&quot;[a,b]&quot; 其中a,b是样式对象\n\n     &lt;div id&#x3D;&quot;app&quot;&gt; \n        &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;\n        &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;mood&quot; @click&#x3D;&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n\n        &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt;\n        &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;mood&quot; @click&#x3D;&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n\n        &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt;\n        &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;classObj&quot; @click&#x3D;&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;\n\n        &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;[styleObj1, styleObj2]&quot;&gt;&#123;&#123;name&#125;&#125; &lt;&#x2F;div&gt; \n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123; \n                name: &#39;尚硅谷&#39;,\n                mood: &#39;normal&#39;,\n                a: true,\n                b: true,\n                classObj: &#123;\n                    atguigu1: false,\n                    atguigu2: false\n                &#125;,\n                styleObj1: &#123;\n                    fontSize: &#39;40px&#39;,\n                    color: &#39;red&#39;, \n                &#125;,\n                styleObj2: &#123;\n                    backgroundColor: &#39;orange&#39;\n                &#125;\n            &#125;,\n            methods: &#123;\n                changeMood() &#123;\n                    this.mood &#x3D; &quot;happy&quot;\n                &#125;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n11_条件渲染1. v-if写法：\n   1. v-if=&quot;表达式&quot;\n   2. v-else-if=&quot;表达式&quot;\n   3. v-else=&quot;表达式&quot;\n   * 适用于：切换频率较低的场景\n   * 特点：不展示的DOM元素直接被移除\n   * 注意：v-if可以和：v-else-if、v-else一起使用\n\n2. v-show\n    * 写法：v-show=&quot;表达式&quot;\n    * 适用于：切换频率较高的场景\n    * 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n    \n    &lt;div id&#x3D;&quot;app&quot;&gt; \n        &lt;!-- 使用v-show做条件渲染 --&gt;\n      &lt;!--   &lt;h2 v-show&#x3D;&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;h2 v-show&#x3D;&quot;1 &#x3D;&#x3D; 3&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;h2 v-if&#x3D;&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt; --&gt;\n        &lt;h2&gt;当前n的值是&#123;&#123;n&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;button @click&#x3D;&quot;n++&quot;&gt;点我n + 1&lt;&#x2F;button&gt;\n        &lt;div v-if&#x3D;&quot;n &#x3D;&#x3D; 1&quot;&gt;Angular&lt;&#x2F;div&gt;\n        &lt;div v-else-if&#x3D;&quot;n &#x3D;&#x3D; 2&quot;&gt;React&lt;&#x2F;div&gt;\n        &lt;div v-else&gt;Vue&lt;&#x2F;div&gt;\n        &lt;template v-if&#x3D;&quot;n &#x3D;&#x3D; 4&quot;&gt;\n            &lt;h1&gt; 北京 &lt;&#x2F;h1&gt;\n            &lt;h2&gt; 上海 &lt;&#x2F;h2&gt;\n            &lt;h3&gt; 武汉 &lt;&#x2F;h3&gt;\n        &lt;&#x2F;template&gt;\n    &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;  \n                name: &#39;尚硅谷&#39;,\n                n: 0\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n12_列表渲染1.基本列表v-for指令：\n        1. 用于展示表数据\n        2. 语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;\n        3. 可遍历：数组，对象，字符串（用的很少），指定次数（用的很少）\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n    \n    &lt;div id&#x3D;&quot;app&quot;&gt;   \n        &lt;h2&gt;人员列表&lt;&#x2F;h2&gt;\n        &lt;ul&gt; \n            &lt;!-- 遍历数组 --&gt;\n            &lt;li v-for&#x3D;&quot;(p, index) of persons&quot; :key&#x3D;&quot;index&quot;&gt;\n                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;---&#123;&#123;index&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;h2&gt;汽车信息&lt;&#x2F;h2&gt;\n        &lt;!-- 遍历对象 --&gt;\n        &lt;ul&gt; \n            &lt;li v-for&#x3D;&quot;(value, key) of car&quot; :key&#x3D;&quot;key&quot;&gt;\n                &#123;&#123;key&#125;&#125;---&#123;&#123;value&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;h2&gt;遍历字符串&lt;&#x2F;h2&gt; \n        &lt;ul&gt; \n            &lt;li v-for&#x3D;&quot;(value, key) of str&quot; :key&#x3D;&quot;key&quot;&gt;\n                &#123;&#123;key&#125;&#125;---&#123;&#123;value&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;h2&gt;遍历次数&lt;&#x2F;h2&gt; \n        &lt;ul&gt; \n            &lt;li v-for&#x3D;&quot;(value, key) of 5&quot; :key&#x3D;&quot;key&quot;&gt;\n                &#123;&#123;key&#125;&#125;---&#123;&#123;value&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;  \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                persons: [\n                &#123;id: &#39;1001&#39;, name: &#39;李华&#39;, age: 12&#125;,\n                &#123;id: &#39;1002&#39;, name: &#39;张三&#39;, age: 45&#125;,\n                &#123;id: &#39;1003&#39;, name: &#39;赵云&#39;, age: 43&#125;,\n                &#123;id: &#39;1004&#39;, name: &#39;刘备&#39;, age: 56&#125;,\n            ],\n                car: &#123;\n                    name: &#39;奥迪&#39;,\n                    price: &#39;80万&#39;,\n                    color: &#39;黑色&#39;\n                &#125;,\n                str: &#39;hello&#39;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n2.key的原理\n\n虚拟DOM中key的作用： key时虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\n对比规则：\n旧虚拟DOM中找到了与新虚拟DOM相同的key:\n若虚拟DOM中内容没变，直接使用之前的真实DOM\n若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM\n\n\n旧虚拟DOM中未找到与新虚拟DOM相同的key, 创建新的真实的DOM，随后渲染到页面\n\n\n用index作为key可能会引发的问题：\n若对数据进行：逆序添加，逆序删除等破坏顺序操作，会产生没有必要的真实DOM更新  &#x3D;&#x3D; 》界面效果没问题，但效率低\n如果结构中还包含输入类的DOM：会产生错误的DOM更新 &#x3D;&#x3D;》界面有问题\n\n\n开发中如何选择key?:\n最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值\n如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n    \n    &lt;div id&#x3D;&quot;app&quot;&gt;  \n        &lt;h2&gt;人员列表（遍历数组）&lt;&#x2F;h2&gt;\n        &lt;button @click.once&#x3D;&quot;add&quot;&gt;添加一个老刘&lt;&#x2F;button&gt;\n        &lt;ul&gt; \n            &lt;!-- 遍历数组 --&gt;\n            &lt;li v-for&#x3D;&quot;(p, index) of persons&quot; :key&#x3D;&quot;p.id&quot;&gt;\n                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;---&#123;&#123;index&#125;&#125;\n                &lt;input type &#x3D; &quot;text&quot;&#x2F;&gt;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt; \n    &lt;&#x2F;div&gt;  \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                persons: [\n                &#123;id: &#39;1001&#39;, name: &#39;李华&#39;, age: 12&#125;,\n                &#123;id: &#39;1002&#39;, name: &#39;张三&#39;, age: 45&#125;,\n                &#123;id: &#39;1003&#39;, name: &#39;赵云&#39;, age: 43&#125;,\n                &#123;id: &#39;1004&#39;, name: &#39;刘备&#39;, age: 56&#125;,\n            ]\n            &#125;,\n            methods: &#123;\n                add() &#123;\n                    const p &#x3D; &#123;id:&#39;004&#39;, name:&#39;老刘&#39;, age:40&#125;\n                    this.persons.unshift(p)\n                &#125;\n            &#125; \n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n\n\n\n3.列表过滤    &lt;div id&#x3D;&quot;app&quot;&gt;   \n        &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入名字&quot; v-model&#x3D;&quot;keyWord&quot;&gt;\n        &lt;ul&gt;  \n            &lt;h2&gt;人员列表&lt;&#x2F;h2&gt;\n            &lt;li v-for&#x3D;&quot;(p, index) of filpersons&quot; :key&#x3D;&quot;index&quot;&gt;\n                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;---&#123;&#123;p.sex&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt; \n    &lt;&#x2F;div&gt;  \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                keyWord: &#39;&#39;,\n                persons: [\n                &#123;id: &#39;1001&#39;, name: &#39;马冬梅&#39;, age: 19, sex: &#39;女&#39;&#125;,\n                &#123;id: &#39;1002&#39;, name: &#39;周冬雨&#39;, age: 20, sex: &#39;女&#39;&#125;,\n                &#123;id: &#39;1003&#39;, name: &#39;周杰伦&#39;, age: 21, sex: &#39;男&#39;&#125;,\n                &#123;id: &#39;1004&#39;, name: &#39;温兆伦&#39;, age: 22, sex: &#39;男&#39;&#125;, \n            ], \n            &#125;,\n            &#x2F;&#x2F;用computed实现\n            computed: &#123;\n                filpersons() &#123;\n                    return this.persons.filter((p)&#x3D;&gt;&#123;\n                        return p.name.indexOf(this.keyWord) !&#x3D;&#x3D; -1\n                    &#125;)\n                &#125;\n            &#125;\n            &#x2F;&#x2F;用watch实现\n            &#x2F;* watch: &#123;\n               keyWord: &#123;\n                immediate: true,\n                handler(val) &#123; \n                    this.filpersons &#x3D; this.persons.filter((p)&#x3D;&gt;&#123;\n                        return p.name.indexOf(val) !&#x3D;&#x3D; -1\n                    &#125;)\n                &#125;\n               &#125;\n                &#125; *&#x2F;\n            &#125;\n        )\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n4.列表排序&lt;div id&#x3D;&quot;app&quot;&gt;   \n        &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入名字&quot; v-model&#x3D;&quot;keyWord&quot;&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 2&quot;&gt;年龄升序&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 1&quot;&gt;年龄降序&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&quot;sortType &#x3D; 0&quot;&gt;原顺序&lt;&#x2F;button&gt;\n        &lt;ul&gt;  \n            &lt;h2&gt;人员列表&lt;&#x2F;h2&gt;\n            &lt;li v-for&#x3D;&quot;(p, index) of filpersons&quot; :key&#x3D;&quot;index&quot;&gt;\n                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;---&#123;&#123;p.sex&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt; \n    &lt;&#x2F;div&gt;  \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false\n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                keyWord: &#39;&#39;,\n                sortType: 0,\n                persons: [\n                &#123;id: &#39;1001&#39;, name: &#39;马冬梅&#39;, age: 19, sex: &#39;女&#39;&#125;,\n                &#123;id: &#39;1002&#39;, name: &#39;周冬雨&#39;, age: 30, sex: &#39;女&#39;&#125;,\n                &#123;id: &#39;1002&#39;, name: &#39;周冬雨&#39;, age: 30, sex: &#39;女&#39;&#125;,\n                &#123;id: &#39;1003&#39;, name: &#39;周杰伦&#39;, age: 21, sex: &#39;男&#39;&#125;,\n                &#123;id: &#39;1004&#39;, name: &#39;温兆伦&#39;, age: 22, sex: &#39;男&#39;&#125;, \n            ], \n            &#125;,\n            &#x2F;&#x2F;用computed实现\n            computed: &#123;\n                filpersons() &#123;\n                    const arr &#x3D; this.persons.filter((p)&#x3D;&gt;&#123;\n                        return p.name.indexOf(this.keyWord) !&#x3D;&#x3D; -1\n                    &#125;)\n                    if(this.sortType) &#123;\n                        arr.sort((p1, p2)&#x3D;&gt;&#123;\n                            return this.sortType &#x3D;&#x3D;&#x3D; 1 ? p2.age-p1.age : p1.age-p2.age\n                        &#125;)\n                    &#125;\n                    return arr\n                &#125;\n            &#125;\n             \n            &#125;\n        )\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n5.Vue监测数据改变的原理1. vue会监视data中所有层次的数据\n2. 如何监测对象中的数据？\n    通过setter实现监视，且要在new Vue时就传入要监测的数据\n    1. 对象中后追加的属性，Vue默认不做响应式处理\n    2. 如需给后添加的属性做响应式，请使用如下API：\n            Vue.set(target, propertyName/index, value)或vm.$set(target, propertyName/index, value)\n3. 如何监测数据中的数据？\n    通过包裹数组更新元素的方法实现，本质就是做了两件事\n   1. 调用原生对应的方法对数组进行更新\n   2. 重新解析模板，进而更新页面\n4. 在Vue修改数组中的某个元素一定要用如下方法：\n   1. 使用这些API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n   2. Vue.set() 或 vm.$set()\n\n Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;vue .js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n    \n    &lt;div id&#x3D;&quot;root&quot;&gt;    \n        &lt;h1&gt;学生信息&lt;&#x2F;h1&gt; \n        &lt;button @click&#x3D;&quot;student.age++&quot;&gt;年龄+1岁&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;&#x2F;button&gt;&lt;br&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;addFriend&quot;&gt;再列表首位添加一个朋友&lt;&#x2F;button&gt;&lt;br&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;updateFirstFriend&quot;&gt;修改第一个朋友的名字为：李四&lt;&#x2F;button&gt;&lt;&#x2F;button&gt;&lt;br&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;addHobby&quot;&gt;添加一个爱好&lt;&#x2F;button&gt;&lt;br&#x2F;&gt;\n        &lt;button @click&#x3D;&quot;updateHobby&quot;&gt;修改一个爱好为:开车&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n        &lt;h2&gt;姓名: &#123;&#123;student.name&#125;&#125;&lt;&#x2F;h2&gt;  \n        &lt;h2 v-show&#x3D;&quot;student.sex&quot;&gt;学生性别: &#123;&#123;student.sex&#125;&#125;&lt;&#x2F;h2&gt;  &lt;br&#x2F;&gt;\n        &lt;h2&gt;年龄: &#123;&#123;student.age&#125;&#125;&lt;&#x2F;h2&gt;  \n        &lt;h2&gt;爱好&lt;&#x2F;h2&gt;\n        &lt;ul&gt;\n            &lt;li v-for&#x3D;&quot;(h,index) of student.hobby&quot; :key&#x3D;&quot;index&quot;&gt;\n                &#123;&#123;h&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;h2&gt;朋友们&lt;&#x2F;h2&gt;\n        &lt;ul&gt;\n            &lt;li v-for&#x3D;&quot;(f,index) of student.friends&quot; :key&#x3D;&quot;index&quot;&gt;\n                &#123;&#123;f.name&#125;&#125; --- &#123;&#123;f.age&#125;&#125;\n            &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n       \n    &lt;&#x2F;div&gt;  \n    &lt;script&gt;\n        Vue.config.productionTip &#x3D; false \n        const vm &#x3D; new Vue(&#123;\n            el: &#39;#root&#39;,\n            data: &#123;\n                name: &#39;尚硅谷&#39;,\n                address: &#39;北京&#39;, \n                student: &#123;\n                    hobby: [&#39;喝酒&#39;, &#39;抽烟&#39;, &#39;烫头&#39;],\n                    name: &#39;tom&#39;,\n                    age: 23,\n                    friends: [\n                        &#123;name: &#39;jerry&#39;, age: 35&#125;,\n                        &#123;name: &#39;Mike&#39;, age: 25&#125;\n                    ]\n                &#125;, \n            &#125;,\n            methods: &#123;\n                addSex() &#123;\n                   &#x2F;&#x2F; Vue.set(this.student, &#39;sex&#39;, &#39;女&#39;)\n                    this.$set(this.student, &#39;sex&#39;, &#39;男&#39;)\n                &#125;,\n                addFriend() &#123;\n                    this.student.friends.unshift(&#123;name: &#39;张三&#39;, age: &#39;23&#39;&#125;)\n                &#125;,\n                updateFirstFriend() &#123;\n                    this.student.friends[0].name &#x3D; &#39;李四&#39;\n                &#125;,\n                addHobby() &#123;\n                    this.student.hobby.push(&#39;学习&#39;)\n                &#125;,\n                updateHobby() &#123;\n                    &#x2F;&#x2F; this.student.hobby.splice(0, 1, &#39;开车&#39;)\n                    Vue.set(this.student.hobby, 0, &#39;开车&#39;)\n                &#125;\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n13_收集表单数据","slug":"第一章Vue基础","date":"2023-01-07T12:21:00.000Z","categories_index":"","tags_index":"Vue2","author_index":"HuangRuYi"},{"id":"de9047ec32ef513a8a645b78d181a805","title":"第二章：MySQL环境搭建","content":"Mysql数据库的账号登录，Mysql演示使用, Mysql的编码设置Mysql的登录\n输入登录账号和密码    mysql -uroot -p123456\n&#96;&#96;&#96;  \n2. 进入之后，查看Mysql版本\n&#96;&#96;&#96; sql\n    select version();\n退出exit&#x2F;quit\n\n\nMysql演示使用\n查看所有的数据库\nshow databases;\n创建自己的数据库\ncreate database 数据库名; \n# 不能与已经存在的数据库重名\ncreate database atguigu;\n使用自己的数据库\n use 数据库名; \nuse atguigu;\n查看某个库的所有表格\nshow tables from 数据库名;\n创建新的表格\n create table 表名称(\n字段名 数据库类型,\n字段名 数据类型\n);\n\ncreate table student(\n    id int,\n    name varchar(20)\n)\n\n查看一个表的数据\nselect * from student;\n\n7.添加一条记录    insert into 表名称 values(值列表);\n\ninsert into student values(1, &#39;张三&#39;);\ninsert into sutdent values(2, &#39;李四&#39;);\n\n查看表的创建信息\nshow create table 表名称\\G\n\nshow create table student\\G\n查看数据库的创建信息\n show create database 数据库名\\G\n删除表格\ndrop table student;\n\n删除数据库\ndrop database 数据库名；\n\nMysql的编码设置","slug":"第二章：MySQL环境搭建","date":"2023-01-06T12:21:00.000Z","categories_index":"","tags_index":"数据库","author_index":"HuangRuYi"}]